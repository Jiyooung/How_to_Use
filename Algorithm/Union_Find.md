# 유니온 파인드 (union-find)
- 파인드<br>
어떤 값이 어느 집합에 속하는지 찾는 것
- 유니온<br>
여러 집합을 합치는 것 (서로 다른 두 집합을 하나의 집합으로 만드는 것)

```
arr
index       : 값 
arr[index] 	: index가 포함된 집합의 번호
	arr[1] = 1 인 경우에는 1자체가 최상위 부모
	arr[2] = 1 인 경우에는 2의 부모가 1, 즉 1과 2는 같은 집합
```
```
1 	4 
|	|	( | : union을 뜻함) 했을 때 arr[5] = ?
4	5
```
정답) arr[5] = 1<br>
1 : 바로 집합의 최강자를 알 수 있음 <br>
4 : 부모의 부모의 부모를 찾아서 최강자를 찾으러 가야함<br>
파인드로 최상위부모를 찾아감으로서 그 값의 집합이름(=최상위부모)을 찾을 수 있음 <br>
소수일 때는 상관 없음, 많을 경우에 효율성으로 1(level차이를) 해주는 게 좋음<br>

## 파인드 함수 구현 방법
```c++
int p[10001];
for (i) p[i] = i;		// 초기 설정, 각 값마다 각자의 부모값(자신)을 만들어줌

int find (int v) {		// 최상위 부모 찾기
	if (p[v] == v) {	// 자기자신이 부모일 때(최상위부모)
		return v;
	}
	return find(p[v]);
	// return p[v] = find(p[v]);	// 최상위 부모로 p[v] 값들이 정리가 됨
}
```

## 유니온 함수 구현 방법
가정)<br>
arr[1] = 1; arr[4] = 1; arr[5] = 1;<br>
arr[2] = 2; arr[3] = 2; arr[6] = 2; arr[7] = 6;<br>
```c++
void uni(int a, int b) {
	int pa = find(a);	// a의 최상위부모 = pa
	int pb = find(b);	// b의 최상위부모 = pb
	// 레벨이 작은 집합을 다른 집합 아래에 붙이는 것이 효율적~!
	// 현재 가정에서는 2집합이 더 높이가 높아서 2집합(L4)에 1집합(L3)을 붙이는 것이 효율적
	// 그러려면 깊이를 알아야해

	p[pb] = pa;
}
```